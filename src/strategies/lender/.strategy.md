# Aave Tokenized Strategy — Variants Design & Implementation Plan

**Scope**: design and full implementation plan (architecture, interfaces, security analysis, tests, deployment, monitoring, governance and gas considerations) for five strategy variants derived from the `AaveV3Lender` tokenized strategy:

1. Leveraged looping strategy (e.g., configurable 1x–5x)
2. Morpho Blue strategy (Morpho adapter replacement)
3. Spark strategy (Spark pool integration)
4. Multi-lender router (Aave + Morpho + Spark allocation router)
5. Pendle-boosted Aave (deposit aTokens into Pendle PT/LP for boosting)

This document assumes the base `AaveV3Lender` from the Tokenized Strategy framework (inherits `BaseStrategy`) as the starting point.

---

## Table of contents

1. Goals & requirements
2. High-level architecture (diagram + components)
3. Common primitives & reusable interfaces
4. Variant-by-variant design (detailed)

   * changes required
   * core flows (deposit, withdraw, harvest, emergency)
   * configuration & governance knobs
   * security considerations and mitigations
   * tests to implement
5. Multi-lender router design (detailed)
6. Pendle boosting design
7. Auditing & formal verification checklist
8. Gas & onchain cost analysis
9. Deployment & rollout plan
10. Monitoring, metrics & onchain observability
11. Operational playbook (emergency flows)
12. Recommended repository structure & CI
13. Example Foundry tests and scripts
14. Appendix: ABI / interfaces / helper pseudocode

---

## 1) Goals & requirements

**Primary goal**: provide safe, modular, auditable strategy implementations that can be plugged into a TokenizedStrategy vault to capture yield from lending markets and optional boost/leveraging, while preserving clear risk boundaries.

**Non-functional requirements**:

* Reusability: maximize code reuse across variants.
* Safety: minimize liquidation/credit risk exposure; add emergency withdraws & time-delay management operations.
* Auditability: small functions, explicit math, no hidden state.
* Observability: expose view functions for accounting and precise on-chain metrics for off-chain monitors.
* Configurability: allow management/strategy roles to tune leverage ratios, slippage thresholds, auction flags, reward sell thresholds, allocation percentages.

**Actors & Roles**:

* Governance: timelocked admin for high-risk params (e.g., max leverage, permissioned adapters).
* Management: day-to-day operators (set fees, unpause, set min sell amounts) — limited authority.
* Strategist: can change strategy-level parameters (e.g., target leverage within governance limits).
* Keepers: bots that call harvest, rebalance, and liquidation-safe actions.

Security assumptions: assume L1 canonical Aave/Morpho/Spark contracts; assume oracle feeds exist for price checks when needed.

---

## 2) High-level architecture

**Components**:

* `BaseStrategy` (from tokenized-framework): ERC-4626 wrapper, reporting, share accounting.
* `AaveV3Lender` (base): single-protocol implementation.
* `LeveragedLoopStrategy` (new): extends `AaveV3Lender` or `BaseStrategy` with borrow/supply loop logic.
* `MorphoAdapter` / `MorphoLender` (new): replaces Aave calls with Morpho equivalent.
* `SparkLender` (new): Spark integration.
* `MultiLenderRouter` (new vault-level router): holds allocations and routes deposits to selected strategies.
* `PendleBooster` (new): contract that accepts aTokens and deposits into Pendle, or strategy that also farms PT/LP.
* Swappers: `UniswapV3Swapper` and `AuctionSwapper` (existing).
* Keepers (off-chain): harvest/claim executors.

**Data flows**:

* Vault → TokenizedStrategy(s) (single or routed) → Underlying protocols (Aave/Morpho/Spark) → Rewards → Swappers → Redeploy

**Diagram (simplified)**:

```
User -> Vault (ERC4626) -> Router? -> Strategy A (Aave) -> Aave v3
                                   Strategy B (Morpho) -> Morpho
                                   Strategy C (Spark) -> Spark
                 Strategy A -> Pendle booster -> Pendle PT/LP
```

---

## 3) Common primitives & reusable interfaces

Create a `IYieldSource` interface that abstracts supply/withdraw/claim for any lender. This lets the router and strategies to interact with different implementations.

```solidity
interface IYieldSource {
  function supply(address token, uint256 amount) external;
  function withdraw(address token, uint256 amount, address to) external returns (uint256);
  function getLiquidity(address token) external view returns (uint256);
  function claimRewards(address to) external returns (address[] memory rewards);
}
```

This interface is intentionally minimal and will be implemented by Aave / Morpho / Spark wrappers.

**Common helper libs**:

* `SafeMath` / `Math` for min/max
* `Accountings` helper for share/assets conversions (use BaseStrategy where possible)
* `HarvestReporter` helper to centralize reward handling patterns

**Role-based access**: keep `onlyManagement`, `onlyGovernance` roles in BaseStrategy — extend with `onlyStrategist` where appropriate.

---

## 4) Variant designs

### A) Leveraged looping strategy (LeveragedLoopStrategy)

**Objective**: increase yield by recursively depositing and borrowing the same collateral to target a configurable leverage factor (e.g., 2x–5x). Use Aave v3 lending only.

**Key design choices**:

* Use Aave `borrow()` + `supply()` loop on a single stable asset (USDC or USDT) only.
* Conservative target LTV (max target < safe threshold): compute `targetLTV` such that the effective health factor stays comfortably above liquidation thresholds.
* Use oracle price checks and off-chain keeper checks to ensure no drift beyond safety bands.

**Core state & params**:

* `maxLeverage` (immutable/constant max allowed by governance)
* `targetLeverage` (configurable within `maxLeverage` bounds)
* `leverageTolerance` (acceptable deviation before rebalance)
* `minHealthFactor` (governance-set minimal HF threshold before forced deleverage)
* `maxIterations` (limit loops to control gas)

**Deposit flow (simplified)**:

1. Receive asset from vault via `BaseStrategy.deposit` call path.
2. _deployFunds(amount):

   * deposit `_amount` to Aave via `supply()`
   * perform borrow+redeploy loops until `currentLeverage` approx `targetLeverage`

**Borrow/supply loop Pseudocode**:

```text
currentSupply = aToken.balanceOf(this)
while(currentLeverage < targetLeverage && iterations < maxIterations) {
  borrowAmount = currentSupply * borrowFraction // function of targetLTV
  pool.borrow(asset, borrowAmount, variableRate, referrer, this)
  pool.supply(asset, borrowAmount, this, referral)
  update currentSupply, currentBorrow
}
```

**Withdraw flow**:

* On withdraw, unwind loops only as necessary to free the requested amount.
* Add `quickUnwind` path for large withdraws: deleverage in several steps and prioritize using idle `asset` before redeeming aTokens.

**Harvest flow**:

* Claim rewards as usual.
* Ensure harvested funds are used first to repay debt if debt > target or to reduce leverage exposure.

**Risk & mitigations**:

* Liquidation risk: enforce `minHealthFactor`, on drift call `deleverage()` to safe state.
* Oracle manipulation: only use secure oracles and perform sanity checks on offchain keeper prices.
* Sandwich attacks on deposit: allow minimal delay or front-run-aware mechanisms (but limited by tokenized framework).

**Testing**:

* Unit tests for loop math (edge cases), HF maintenance, withdraw unwind, emergency deleverage.
* Forked mainnet integration tests for Aave to simulate rates and liquidation.

**Access control**:

* Only governance can set `maxLeverage`.
* Management/strategist can set `targetLeverage` but within `maxLeverage`.

---

### B) Morpho Blue strategy (MorphoLender)

**Objective**: replace Aave direct supply with Morpho’s supply which yields better rates by matching peers (Morpho acts as adapter on top of Aave/Compound).

**Primary changes vs AaveV3Lender**:

* Use Morpho’s `supply()` / `withdraw()` API instead of Aave's Pool. Morpho has separate market addresses per token.
* Rewards: claim Morpho-specific rewards if any or continue claiming aToken incentives when applicable.
* Accounting: Morpho uses a different interest model & internal ERC20 wrappers — ensure `balanceOf` and `totalSupply` semantics are correct.

**Implementation notes**:

* Implement `MorphoAdapter` that implements `IYieldSource`.
* Keep `BaseStrategy` identical and swap `lendingPool.supply()` → `morpho.supply()` in `_deployFunds`.
* Some Morpho markets require first approving to `morpho` contract.

**Risks**:

* Morpho security: follow its recommended interaction patterns.
* Slightly different reward patterns; ensure correctness when converting to asset during harvest.

**Testing**:

* Forked tests against Morpho adapters.

---

### C) Spark strategy (SparkLender)

**Objective**: integrate Spark’s lending pool (e.g., Spark protocol building leverage-enabled lending) as the yield source.

**Primary changes**:

* Replace Aave pool calls with Spark pool equivalents.
* Spark may use different tokenized wrappers; ensure correct `balanceOf` and `withdraw` semantics.
* Rewards: Spark often emits reward tokens; integrate reward claims and swaps similarly.

**Implementation notes**:

* Use an adapter or wrapper `SparkAdapter` implementing `IYieldSource`.

**Risks & testing**: similar to Morpho. Pay attention to any TWAP or special oracle requirements by Spark.

---

### D) Multi-lender router (MultiLenderRouter)

**Objective**: allow a vault to split deposits across multiple single-protocol strategies (Aave, Morpho, Spark) with dynamic allocation and rebalancing.

**Design choices**:

* Router is either an external contract used by a vault or the vault itself tracks strategy allocation. Two patterns:

  1. **Vault-level router**: Vault holds funds and mints shares; it calls strategies' `depositFor` to push funds around.
  2. **Router-as-strategy**: A single tokenized strategy that internally manages child strategies and reports aggregate assets to the base vault. This fits the TokenizedStrategy standard better — implement `MultiStrategy` that inherits `BaseStrategy` and manages an array of child `BaseStrategy` contracts.

**I recommend**: Router-as-strategy (a single tokenized strategy wrapper that composes multiple child strategies). This keeps a single ERC-4626 interface for the vault.

**Key features**:

* Child strategy registry: add/remove child strategies (only governance, with timelock).
* Allocation percentages per child (sum to 100% with small rounding tolerance).
* Rebalance function to move funds between children according to target allocations.
* Emergency drain: if a child strategy is compromised, governance can set allocation to 0 and withdraw funds from child.
* Fee accounting: aggregate fees across children and report.

**Core functions**:

* `_deployFunds(_amount)`: split `_amount` into chunks and call childStrategy.deployFunds(amountChunk)`or`depositFor` if supported.
* `_freeFunds(_amount)`: determine which child strategies to pull from (use liquidity score and ordering for cheapest withdraw).
* `_harvestAndReport()`: call child.harvestAndReport() or child-specific claim then aggregate totalAssets.

**Rebalancing**:

* Rebalance by calling `reallocate()` — read current child assets and compute delta to target.
* Use two-step rebalances to avoid slippage: 1) withdraw from overweighted children, 2) deposit to underweighted.

**Governance knobs**:

* `maxChildStrategies` limit
* `minLiquidityReserve` to keep on-vault for fast withdraw
* `rebalanceThreshold` (when to rebalance)

**Risks & mitigations**:

* If child misreports, router must cross-check via `totalIdle()` & onchain balances.
* Emergency withdrawal path: withdraw all from children into router and hold as idle.

**Testing**:

* Simulate adding/removing children, rebalances with varying liquidity, simulate child failure.

---

### E) Pendle-boosted Aave strategy (PendleBoostedAave)

**Objective**: deposit Aave aTokens into Pendle to obtain PT/LP for boosted yield (lock future yield) and/or sell PT for immediate gain.

**Options**:

1. **Single-step**: after supplying into Aave, strategy deposits the received aToken into Pendle Market to receive PT (Principal Token) or yield-bearing LP.
2. **Two-mode**: optionally keep some portion of aTokens in Aave while boosting only part into Pendle.

**Key flows**:

* `_deployFunds`: supply to Aave → receive aTokens → approve & deposit aTokens into Pendle to get PT/yTokens.
* Harvest: claim underlying rewards + Pendle yields; some rewards are claimable only via PT maturity — strategy needs to track time-to-maturity and realize gains by trading PT or letting it mature.
* Exit: withdraw from Pendle back to aToken, then redeem aToken on Aave.

**Special considerations**:

* Pendle markets often require expiry handling and PT/YT semantics. Implement handling for expiry and settlement.
* Slippage & liquidity: selling PT on secondary markets may be illiquid; use `minAmountToSellMapping` pattern.

**Risks**:

* Added counterparty & market risk from Pendle market.
* Time-lock / maturity risk — funds may be locked until expiry.

**Testing**:

* Fork tests with Pendle markets; simulate expiry and PT trades.

---

## 5) Multi-lender router — detailed interfaces & algorithms

**Contract**: `MultiStrategyTokenized` (inherits `BaseStrategy`)

**Storage**:

```solidity
struct Child { address strategy; uint256 allocation; bool active; }
Child[] public children;
uint256 public totalAlloc; // should be 10000 (basis points)
uint256 public reserve; // idle amount retained on this contract
```

**Key functions**:

* `addChild(strategy, allocation)` (governance)
* `removeChild(index)` (governance + timelock)
* `setAllocation(index, allocation)` (governance)
* `rebalance()` (anyone/keeper)
* `_deployFunds(amount)` — splits and calls deposit into each child
* `_freeFunds(amount)` — withdraws from children respecting liquidity
* `_harvestAndReport()` — iterates children and requests their accounting

**Algorithm for withdraw**:

1. If `reserve >= amount` return reserve.
2. Else compute needed = amount - reserve.
3. Sort children by `availableWithdrawLimit()` descending (more liquid first).
4. Pull from them until `needed` satisfied.

**Rebalance algorithm**:

* Compute current % per child via `childAssets = child.totalAssets()`.
* For each child compute `delta = targetAlloc - currentAlloc` and perform withdraw/deposit accordingly in small steps to avoid slippage.

**Atomicity**: Rebalancing is not atomic; watchers must ensure repeated small rebalances.

---

## 6) Pendle boosting design — specifics

**Two modes**:

* `BoostMode.ON`: deposit all aTokens to Pendle; strategy holds PT/YT.
* `BoostMode.PARTIAL`: only deposit `boostPercent` of aTokens.

**Key functions**:

* `depositToPendle(amount)`
* `withdrawFromPendle(amount)`
* `sellPT(token, minOut)` via Uni/Auction if needed

**Maturity handling**:

* Keep mapping `expiry -> amount` for PTs; allow strategist to schedule sell at expiry.

---

## 7) Auditing & formal verification checklist

* Ensure `debt` and `supply` accounting are consistent and not subject to rounding errors.
* No unbounded loops on-chain (all loops must be bounded by `maxIterations`).
* Ensure approvals are tight and only to expected contracts.
* Reentrancy guards on state-changing external functions.
* Check invariants: `totalAssets()` reported by strategy >= totalIdle (can't underreport idle).
* Check that `availableWithdrawLimit()` >= `totalIdle()`.
* Timelock for governance-critical changes (e.g., adding child strategies, changing `maxLeverage`).

---

## 8) Gas & onchain cost analysis

**Leveraged looping**: expensive during `deployFunds` because of repeated `borrow()` and `supply()` calls — cap `maxIterations` and provide warm-start gas estimates to keep operations feasible.

**Router**: rebalancing costs scale with number of children and number of small transfers. Use off-chain rebalancers to call batched rebalances.

**Pendle**: depositing/withdrawing PT may be moderate gas cost; selling PT on Uni may be high depending on path.

Optimization tips:

* Combine allowances into single `approve` calls (use `safeApprove` once).
* Use `type(uint256).max` approvals only where safe and documented.
* Use events to allow off-chain monitoring instead of on-chain large state updates.

---

## 9) Deployment & rollout plan

1. Develop each adapter & strategy in a feature branch.
2. Unit test with Foundry; use mainnet forks for integration tests.
3. Security reviews and internal audits.
4. Deploy to testnet (Goerli/Linea/Base testnets) and run an incentivized test program.
5. Deploy minimal-capital production rollout (small TVL) under timelock governance.
6. Monitor health factors and do gradual TVL increase.

---

## 10) Monitoring & metrics

Expose the following view functions for off-chain monitors:

* `totalAssets()` (per strategy & per child)
* `totalDebt()` for leveraged strategies
* `healthFactor()` (leveraged)
* `currentLeverage()` (leveraged)
* `pendingRewards()`
* `availableWithdrawLimit()`

Events to emit:

* `LeverageChanged(old, new)`
* `Rebalanced(from, to, amount)`
* `ChildAdded/Removed`/`AllocationChanged`
* `EmergencyWithdrawCalled`

Keep an off-chain Grafana/Prometheus system with alerts for:

* HF < threshold
* Rebalance required
* Reward sale failures

---

## 11) Operational playbook (emergency flows)

* `pause()` strategy (management)
* `shutdown()` (governance) — calls `_emergencyWithdraw()` and sends funds to the vault
* `setAllocation(child,0)` then `withdrawAllFromChild(child)` for compromised child
* Use `auction` fallback for selling reward tokens to avoid revert on illiquid pairs

---

## 12) Recommended repository structure & CI

```
/contracts
  /adapters
    AaveAdapter.sol
    MorphoAdapter.sol
    SparkAdapter.sol
  /strategies
    AaveV3Lender.sol
    LeveragedLoopStrategy.sol
    PendleBoostedAave.sol
    MultiStrategyTokenized.sol
  /periphery
    UniswapV4
/tests
/scripts
/forge.toml
/hardhat.config.ts (if using hardhat for scripts)
/CI (foundry test + slither + mythx or other scanners)
```

CI pipeline:

* `forge test` (unit)
* `forge test --fork-url` (integration mainnet fork smoke tests)
* `slither` static analysis
* `mythx` or `sorbet` for deeper scanning

---

## 13) Example Foundry tests & scripts (high-level)

* `test/Leveraged/looping.t.sol`: test deposit with target leverage 3x; simulate borrow rate changes and test automatic deleverage at HF threshold.
* `test/MultiRouter/rebalance.t.sol`: start with single child, add second child, and rebalance.
* `test/Pendle/expiry.t.sol`: deposit, simulate expiry, and settle.

---

## 14) Appendix: key interface snippets & pseudocode

**IYieldSource** (already shown earlier)

**Child accounting snapshot**:

```solidity
function childTotalAssets(address child) public view returns(uint256) {
  return ITokenizedStrategy(child).totalAssets();
}
```

**Leverage math**

```text
leverage = totalSupplyExposure / equity
where: equity = totalSupplyExposure - totalBorrow
```

**Unwind example**

```text
function unwindToAmount(uint256 wantFree) {
  while (free < wantFree && borrowed > 0) {
    uint256 toRepay = min(borrowed, chunkSize)
    pool.repay(asset, toRepay, variableRate, address(this))
    pool.withdraw(asset, toRepay, address(this))
    update balances
  }
}
```

---

## Final notes & recommended next steps

**Prioritize**:

1. Implement `IYieldSource` + `AaveAdapter` + tests. (base line)
2. Implement `MorphoAdapter` & `SparkAdapter` as drop-in replacements.
3. Implement `MultiStrategyTokenized` router-as-strategy.
4. Implement `LeveragedLoopStrategy` with strict safety caps.
5. Implement `PendleBoostedAave` with partial boost mode.

# Aave Tokenized Strategy — Variants + Uniswap v4 Hooks Design & Implementation Plan

**Scope**: practical design and implementation plan for five strategy variants derived from the `AaveV3Lender` tokenized strategy — plus a new integration layer using **Uniswap v4 hooks** to enable fee-innovation (adaptive fees, micro-donations, verified-wallet discounts, public-goods routing) and safer reward distribution.

**Variants covered**

1. Leveraged looping strategy (1x–5x, safe defaults)
2. Morpho Blue strategy (Morpho adapter)
3. Spark strategy (Spark adapter)
4. Multi-lender router (Aave + Morpho + Spark allocations)
5. Pendle-boosted Aave (deposit aTokens into Pendle PT/LP)

**New**: Uniswap v4 Hooks integration to enable programmable per-swap behavior (micro-donations, adaptive fees based on volatility/gas, verified-wallet discounts, public-goods fee routing).

---

## Table of contents

1. Why Uniswap v4 hooks? (short)
2. Goals & high-level requirements (strategy + fee innovations)
3. Architecture overview (components + hooks)
4. Uniswap v4 Hooks design patterns

   * fee-orchestration hook
   * donation verification hook
   * verified-wallet discount hook
   * anti-flash-LP / reward-gating hook
5. Variant-by-variant modifications to use hooks
6. Multi-lender router — hooking swaps & routing fees
7. Security, UX & governance model for hook policies
8. Tests, monitoring, and gas considerations
9. Deployment & rollout plan
10. Appendix: example hook pseudocode and calldata flows

---

## 1) Why Uniswap v4 hooks?

Uniswap v4 introduces on-chain hook handlers at points in the swap flow. Hooks let integrators execute small logic atomically during swaps (or liquidity changes) without changing the pool core. For our strategies this enables:

* **Per-swap programmable fees** — adapt fees to volatility, network congestion, or token attributes.
* **Micro-donations** — route a configurable small portion of swap fees to public-goods or charity addresses atomically.
* **Verified-wallet discounts** — apply fee discounts after on-chain proof of donation or governance participation.
* **Reward-gating** — prevent short-lived flash LPs from harvesting distribution rewards by checking deposit time / proof of stake.

This avoids costly off-chain orchestration and simplifies accounting: fee split, donation, and verification can happen within the same atomic swap transaction.

---

## 2) Goals & high-level requirements

**Primary goals**

* Provide safe, modular yield strategies that plug into the TokenizedStrategy vault.
* Innovate swap economics using Uniswap v4 hooks to: adaptive fees, micro-donations, public-goods routing, verified-wallet discounts, and prevention of flash-LP reward extraction.

**Non-functional**

* Auditability and minimal trusted code in hooks.
* Governance-controlled policies with timelock and configurable parameters.
* Low-friction UX for users (donation optional/per-user configurable; verified discounts opt-in via signature/donation proof).
* Gas-efficiency: hooks must be tiny and bounded.

**Actors & Roles**

* Governance (timelock) — config of protocol-level parameters, hook addresses, public-good recipients.
* Management — daily param tuning under hard bounds.
* Keepers — call harvest/rebalance.
* Verification oracle / Proof service — optional off-chain service that writes attestations on-chain or issues signed proofs for wallets.

---

## 3) Architecture overview

**New components**

* `HookManager` — central router for hook calls; small, auditable logic that maps pool → hook policy and holds public-good recipients and rates.
* `FeeOrchestratorHook` — the on-pool hook implementation used by Uniswap v4 pools (minimal, delegates to `HookManager`).
* `VerificationRegistry` — onchain registry of donation/gov proofs (signed attestations or merkle roots) to enable wallet discounts.
* `SwapRelayer` — optional contract for UX-friendly swaps that sets hook metadata (user donation opt-in, verified proof) when calling pool.

**Existing components (reused)**

* `AaveV3Lender`, `MorphoAdapter`, `SparkAdapter`, `MultiStrategyTokenized`, `PendleBoostedAave` — strategies and adapters.
* `UniswapV3Swapper` / `AuctionSwapper` — keep for off-pool swaps; Uniswap v4 hook flows preferred for primary swaps to capture innovation.

**High-level flow**

```
User -> Vault -> Strategy -> Reward sale
                                 ↳ Swap via Uniswap v4 pool (pool has FeeOrchestratorHook)
                                         ↳ HookManager consults policy (adaptive fee, donation, discount)
                                         ↳ Hook performs fee split + optional donation + returns net amount
                                         ↳ Strategy receives asset and redeploys
```

---

## 4) Uniswap v4 Hooks design patterns

Important constraints: hooks must be deterministic, gas-bounded, and minimal. Put complex policy in `HookManager` but keep computations small in-hook (simple lookups and multiplications).

### 4.1 Fee-Orchestration Hook (core)

**Purpose**: compute per-swap fee splits and route portions to treasury, public-goods, and protocol revenue. Supports adaptive fees based on inputs.

**Inputs (from swap calldata)**

* `protocolPolicyId` — which policy to use (pool-level default or per-user override via SwapRelayer)
* `userFlags` — bitmask: donate|verified|discountRequested
* `priceVolatilityIndex` — optional signed oracle snapshot (small integer) or onchain volatility proxy
* `gasPressureIndex` — small int from relayer (optional)

**Outputs / actions (atomic)**

* collect fee portion (percentage basis points of trade) to `treasury` & `publicGoods` addresses
* apply verified-wallet discount by lowering fee bps
* ensure fee amounts do not exceed configured maxima

**Security**

* Hook only validates proofs and calls `HookManager` for policy. `HookManager` uses `onlyGovernance` setters.

### 4.2 Donation Verification Hook

**Purpose**: optionally require a donation proof before executing swap (used for special pools or discounts). If `requireDonation` set, the hook will revert unless `VerificationRegistry` contains a recent donation attestation.

**Use-cases**

* Pools where every swap must trigger a micro-donation (configurable per user/pool)
* Discounts only for wallets that donated in the last X days

### 4.3 Verified-wallet Discount Hook

**Purpose**: Apply fee discounts after validating an on-chain proof (e.g., a signed receipt of donation or governance vote proof). The hook computes discounted fee and routes the remainder.

**Proof Sources**

* Signed message from VerificationService
* Merkle-proof into `VerificationRegistry`

### 4.4 Anti-Flash-LP / Reward-Gating Hook

**Purpose**: prevent liquidity providers or swappers that try to game reward distributions via flash deposits. The hook tracks per-wallet timestamps and can gate receiving reward multipliers (require minimum time-in-position) or require a minimum `timeLock` before rewards are active.

Implementation choices:

* Minimal on-hook check: read `StakeRegistry` mapping `lastProvideTimestamp[wallet]` and revert if too recent for reward-eligible action.
* For withdraws and swaps, allow instant liquidity but disallow reward claims until the hold period passes.

---

## 5) Variant-by-variant changes to use hooks

### A) LeveragedLoopStrategy

* **Reward sells**: use Uniswap v4 pools with `FeeOrchestratorHook` to auto-donate a small portion of sold rewards to public goods and route protocol revenue separately.
* **Safety**: leverage-target-dependent adaptive fee (higher fee when volatility index high to discourage aggressive rebalancing).
* **Implementation notes**: when borrow/supply loops trigger many internal swaps (rare), prefer internal accounting to batch swaps to avoid repeated hook overhead.

### B) MorphoBlue strategy

* Use hooks when selling Morpho rewards or swapping between assets.
* For markets where Morpho yields are sustainable, apply lower public-good donation rates to encourage long-term LPs.

### C) Spark strategy

* Spark often supports leverage — combine Spark risk signals with `HookManager` to raise fees if HF low.

### D) Multi-lender router

* **Per-strategy policy**: Router assigns `policyId` per child-strategy so swaps realized by each child follow different fee/donation rules.
* **Rebalance**: Rebalance swaps call the pool with `userFlags` set to `protocol` (no discount) and `donation` true if governance desires.
* **On-chain accounting**: `HookManager` emits structured events for donation & fee splits; router aggregates these.

### E) PendleBoostedAave

* When selling PT or YT, Penlde markets may be illiquid — set `minAmountToSellMapping` and mark `policyId` to prefer Auction fallback. Hooks can mark these swaps as `auctionPreferred=true` and lower donation percentages to avoid revert.

---

## 6) Multi-lender router — hooking swaps & routing fees

**Key idea**: the router calls child strategies' `sellReward()` via Uniswap v4 pools that include the FeeOrchestratorHook. Each child strategy indicates `policyId` and `donationPercent` when selling rewards.

**Accounting**:

* `HookManager` emits `FeeSplit(policyId, pool, amount, treasuryAmount, publicGoodsAmount, timestamp)` events.
* Router reads events off-chain (or via indexer) and updates offchain dashboards & final distribution transactions if needed.

**Governance**:

* Governance can set default `policyId` per child strategy and override per-swap using `SwapRelayer` with signed permission.

---

## 7) Security, UX & governance

**Security**

* Keep hooks minimal: they should only do arithmetic, mapping lookups, and small state reads/writes. Complex decisions remain in `HookManager` (also audited).
* All governance changes to hook policies go through a timelock (e.g., 48–72 hours) and are evented.
* Use `reentrancyGuard` and limit external calls from hooks.

**UX**

* `SwapRelayer` provides user-friendly metadata attachments ("donate 0.05% to ClimateFund, apply verified-wallet discount") signed by user to avoid UI friction.
* Wallets that opt-in to automatic micro-donation get a receipt (onchain event) that can be used later for discounts.

**Governance model**

* `policyId` records: `{donationBps, protocolFeeBps, verifiedDiscountBps, requireDonation, auctionPreferred}`
* Governance can add/remove `publicGoods` recipients and adjust caps.

---

## 8) Tests, monitoring & gas

**Tests**

* Unit tests for hook logic (edge cases: discount+donation, zero-fee state, auction fallback).
* Integration tests using Uniswap v4 pool mocks to ensure atomic fee routing and that strategies receive expected nett amounts.
* Forked mainnet tests for reward selling flows across Aave/Morpho/Pendle.

**Monitoring**

* Expose `policyId` metrics: donations collected, protocol revenue, discount usage.
* Alerts for: donation failures, excessive fee rates, policy mismatch between router & hook.

**Gas**

* Hooks must be O(1) and limited to a handful of SSTORE/SLOADs.
* Batch reward sells off-chain where possible; prefer single on-chain swap with hooks per harvest.

---

## 9) Deployment & rollout plan

1. Implement `HookManager` + small `FeeOrchestratorHook` and test locally with pool mocks.
2. Implement `SwapRelayer` UX helper (off-chain signed metadata) and `VerificationRegistry` proof format.
3. Integrate hooks into a test Uniswap v4 deployment and run integration tests with strategies.
4. Start feature-gated rollout: enable donation opt-in first, then enable verified discounts (low %), then enable mandatory donations on select pools.
5. Gradually increase donationBps and enable router-wide defaults with timelock.

---

## 10) Appendix — example hook pseudocode

**FeeOrchestratorHook (simplified)**

```solidity
// Called by Uniswap v4 pool during swap
function onSwapHook(bytes calldata hookData) external returns(bytes memory) {
  (uint256 policyId, uint8 userFlags, uint16 priceVolIdx) = abi.decode(hookData,...);
  Policy memory p = HookManager.getPolicy(policyId);

  uint256 grossFee = computeGrossFee(msg.valueOrAmount, p.baseBps, priceVolIdx);
  if((userFlags & VERIFIED_FLAG) != 0) {
    grossFee = grossFee * (10000 - p.verifiedDiscountBps) / 10000;
  }

  uint256 donation = grossFee * p.donationBps / 10000;
  uint256 protocolCut = grossFee - donation;

  // transfer fee portions atomically
  if(donation > 0) ERC20.transfer(p.publicGoodsRecipient, donation);
  if(protocolCut > 0) ERC20.transfer(p.treasury, protocolCut);

  emit HookFee(policyId, msg.sender, grossFee, donation, protocolCut);

  // return any hook-specific data to pool
  return abi.encode(true);
}
```

**VerificationRegistry**: simple merkle root or mapping of wallet => expiry timestamp of proof.

---

## Final notes & recommended next steps

1. Implement the `HookManager` + minimal `FeeOrchestratorHook` reference and a mocked Uniswap v4 pool for unit tests.
2. Add a `SwapRelayer` to attach user metadata (opt-in donation, verify proofs) to swaps so wallets get receipts.
3. Integrate with `AaveV3Lender` reward selling flow: replace _swapFrom(...) calls with Uniswap v4 swap that sets `policyId` and `userFlags` depending on strategy (e.g., `useAuction`, `verified`).
4. Run forked integration tests to validate donation routing & discount correctness.

If you want, I can now:

* scaffold the Solidity reference for `HookManager` + `FeeOrchestratorHook` + `SwapRelayer` (with comments), or
* generate Foundry tests and a Uniswap v4 pool mock to run the hook flows, or
* update the existing canvas doc with code snippets for your repo.

Which next step do you want? (pick: `scaffold-hooks`, `tests-mock`, `integrate-aave-sell` )

--------------------------------------------
That hi alll this target of strtaegy:

Reserve Structure of aave
Each reserve within an Aave market provides comprehensive lending and borrowing data for a specific asset, including:

Token information (underlying, aToken, vToken addresses and metadata)

Supply information (APY, liquidity, caps, collateral configuration)

Borrow information (APY, available liquidity, utilization rates, caps)

Reserve incentives (Merit programs, Aave governance rewards)

Market mechanics (flash loans, permits, pause/freeze states)

Efficiency mode (eMode) configurations for the asset

Isolation mode settings (if applicable)

User-specific state (balances, borrowable amounts, collateral usage)